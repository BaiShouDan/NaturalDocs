/*
	Include in output:

	This file is part of Natural Docs, which is Copyright © 2003-2013 Greg Valure.
	Natural Docs is licensed under version 3 of the GNU Affero General Public
	License (AGPL).  Refer to License.txt or www.naturaldocs.org for the
	complete details.

	This file may be distributed with documentation files generated by Natural Docs.
	Such documentation is not covered by Natural Docs' copyright and licensing,
	and may have its own copyright and distribution terms as decided by its author.


	Substitutions:

		`PrefixObject_Prefix = 0
		`PrefixObject_KeywordObjects = 1
		`PrefixObject_Ready = 2
		`PrefixObject_DOMLoaderID = 3

		`KeywordObject_HTMLName = 0
		`KeywordObject_SearchText = 1
		`KeywordObject_MemberObjects = 2
		`KeywordObject_ParentID = 3

		`MemberObject_HTMLQualifier = 0
		`MemberObject_HTMLName = 1
		`MemberObject_SearchText = 2
		`MemberObject_TopicType = 3
		`MemberObject_FileHashPath = 4
		`MemberObject_ClassHashPath = 5

		`UpdateSearchDelay = 350

*/

"use strict";


/* Class: NDSearch
	___________________________________________________________________________

*/
var NDSearch = new function ()
	{

	// Group: Functions
	// ________________________________________________________________________


	/* Function: Start
	*/
	this.Start = function ()
		{

		// UI variables

		this.domSearchField = document.getElementById("NDSearchField");

		this.domSearchResults = document.createElement("div");
		this.domSearchResults.id = "NDSearchResults";
		this.domSearchResults.style.display = "none";
		this.domSearchResults.style.position = "fixed";

		if (NDCore.IEVersion() == 6)
			{  this.domSearchResults.style.position = "absolute";  }

		this.domSearchResultsContent = document.createElement("div");
		this.domSearchResultsContent.id = "SeContent";

		this.domSearchResults.appendChild(this.domSearchResultsContent);
		document.body.appendChild(this.domSearchResults);

		// this.updateTimeout = undefined;
		this.openParentIDs = [ ];
		this.highestAssignedParentID = 0;


		// Search data variables

		// We delay loading search/index.js until the search field is activated

		// this.allPrefixes = undefined;
		this.allPrefixesStatus = `NotLoaded;
		this.prefixObjects = { };


		// Event handlers

		this.domSearchField.onfocus = function () {  NDSearch.OnFieldFocus();  };
		this.domSearchField.onblur = function () {  NDSearch.OnFieldBlur();  };
		this.domSearchField.onkeyup = function (event) {  NDSearch.OnFieldKeyUp(event);  };

		this.domSearchResults.onfocus = function () {  NDSearch.OnResultsFocus();  };
		this.domSearchResults.onblur = function () {  NDSearch.OnResultsBlur();  };
		this.domSearchResults.onkeyup = function (event) {  NDSearch.OnResultsKeyUp(event);  };


		// Initialization

		this.Deactivate();
		};


	/* Function: Update
	*/
	this.Update = function ()
		{
		// This may be called by prefix data loaders after the field was deactivated so we have to check.
		if (!this.IsActive())
			{  return;  }

		var searchInterpretations = this.GetSearchInterpretations();

		if (searchInterpretations.length == 0)
			{
			this.HideResults();
			return;
			}

		if (this.allPrefixesStatus != `Ready)
			{
			this.domSearchResultsContent.innerHTML = this.BuildSearchingStatus();
			this.ShowResults();
			return;
			}

		var searchInterpretationPrefixes = this.GetMatchingPrefixes(searchInterpretations);

		this.RemoveUnusedPrefixObjects(searchInterpretationPrefixes);

		if (searchInterpretationPrefixes.length == 0)
			{
			this.domSearchResultsContent.innerHTML = this.BuildNoMatchesStatus();
			this.ShowResults();
			return;
			}

		var location = new NDLocation(window.location.hash);
		var favorClasses = (location.type == "Class" || location.type == "Database");

		var buildResults = this.BuildResults(searchInterpretations, searchInterpretationPrefixes, favorClasses);
		
		this.domSearchResultsContent.innerHTML = buildResults.html;
		this.ShowResults();

		if (buildResults.prefixDataToLoad != undefined)
			{  this.LoadPrefixData(buildResults.prefixDataToLoad);  }
		};



	// Group: Event Handlers
	// ________________________________________________________________________


	/* Function: OnFieldFocus
	*/
	this.OnFieldFocus = function ()
		{
		if (!this.IsActive())
			{  this.Activate();  }
		// Otherwise it might be receiving focus back from the search results
		};


	/* Function: OnFieldBlur
	*/
	this.OnFieldBlur = function ()
		{
		// IE switches focus to the results if you click on a scroll bar
//		if (document.activeElement == undefined || document.activeElement.id != "NDSearchResults")
//			{  this.Deactivate();  }
		};


	/* Function: OnFieldKeyUp
	*/
	this.OnFieldKeyUp = function (event)
		{
		if (event === undefined)
			{  event = window.event;  }

		if (event.keyCode == 27)  // ESC
			{  this.Deactivate();  }
		else
			{
			if (this.updateTimeout == undefined)
				{
				this.updateTimeout = setTimeout(
					function ()
						{
						clearTimeout(NDSearch.updateTimeout);
						NDSearch.updateTimeout = undefined;

						NDSearch.Update();
						},
					`UpdateSearchDelay);
				}
			}
		}


	/* Function: OnResultsFocus
	*/
	this.OnResultsFocus = function ()
		{
		};


	/* Function: OnResultsBlur
	*/
	this.OnResultsBlur = function ()
		{
		if (document.activeElement == undefined || document.activeElement.id != "NDSearchField")
			{  this.Deactivate();  }
		};


	/* Function: OnResultsKeyUp
	*/
	this.OnResultsKeyUp = function (event)
		{
		if (event === undefined)
			{  event = window.event;  }

		if (event.keyCode == 27)  // ESC
			{  this.Deactivate();  }
		}


	/* Function: OnUpdateLayout
	*/
	this.OnUpdateLayout = function ()
		{
		// Check for undefined because this may be called before Start().
		if (this.domSearchResults != undefined)
			{  this.PositionResults();  }
		};

	
	
	// Group: Search Functions
	// ________________________________________________________________________


	/* Function: GetSearchInterpretations
		Reads the contents of <domSearchField> and returns it as an array of normalized interpretations compatible with
		the search text Natural Docs generates for the data files .  Usually there will only be one, but there may be more 
		if the search text is ambiguous.  There may also be none, in which case it will return an empty array.
	*/
	this.GetSearchInterpretations = function ()
		{
		// DEPENDENCY: This must match what is done in Engine.SearchIndex.Entry.Normalize().

		var interpretations = [ ];
		var normalizedSearchText = this.domSearchField.value.toLowerCase();

		// Trim and condense whitespace
		normalizedSearchText = normalizedSearchText.replace(/\s+/g, " ");
		normalizedSearchText = normalizedSearchText.replace(/^ /, "");
		normalizedSearchText = normalizedSearchText.replace(/ $/, "");

		// Remove spaces unless between two alphanumeric/underscore characters
		normalizedSearchText = normalizedSearchText.replace(/([^a-z0-9_]) /g, "$1");  // Substitution because JavaScript has no (?<=) for lookbehinds
		normalizedSearchText = normalizedSearchText.replace(/ (?=[^a-z0-9_])/g, "");

		// Normalize separators
		normalizedSearchText = normalizedSearchText.replace(/::|->/g, ".");
		normalizedSearchText = normalizedSearchText.replace(/\\/g, "/");

		// Remove leading separators.  We don't have to worry about whitespace between them and the rest.
		normalizedSearchText = normalizedSearchText.replace(/^[./]+/, "");

		if (normalizedSearchText == "")
			{  return interpretations;  }

		interpretations.push(normalizedSearchText);


		// If the search text ends with : or - it's possible that it's the first character of :: or ->.  Provide an alternate
		// search string so relevant results don't disappear until the second character is added.

		var lastChar = normalizedSearchText.charAt(normalizedSearchText.length - 1);

		if (lastChar == ":" || lastChar == "-")
			{  interpretations.push(normalizedSearchText.substr(0, normalizedSearchText.length - 1) + ".");  }


		return interpretations;
		};


	/* Function: GetMatchingPrefixes
		Returns an array of prefixes from <allPrefixes> that apply to the passed search text array.
	*/
	this.GetMatchingPrefixes = function (searchTextArray)
		{
		var matchingPrefixes = [ ];

		if (this.allPrefixesStatus != `Ready)
			{  return matchingPrefixes;  }


		// Add each prefix to the array

		for (var i = 0; i < searchTextArray.length; i++)
			{
			var searchText = searchTextArray[i];
			var searchPrefix = this.MakePrefix(searchText);

			if (searchPrefix != undefined && searchPrefix != "")
				{
				var prefixIndex = this.GetAllPrefixesIndex(searchPrefix);

				while (prefixIndex < this.allPrefixes.length)
					{
					if (this.allPrefixes[prefixIndex].length >= searchPrefix.length &&
						this.allPrefixes[prefixIndex].substr(0, searchPrefix.length) == searchPrefix)
						{  
						matchingPrefixes.push(this.allPrefixes[prefixIndex]);  
						prefixIndex++;
						}
					else
						{  break;  }
					}
				}
			}


		if (searchTextArray.length <= 1)
			{  return matchingPrefixes;  }


		// If there was more than one, sort the combined array and remove duplicates.

		matchingPrefixes.sort();

		for (var i = 1; i < matchingPrefixes.length; /* no auto-increment */)
			{
			if (matchingPrefixes[i] == matchingPrefixes[i - 1])
				{  matchingPrefixes.splice(i, 1);  }
			else
				{  i++;  }
			}

		return matchingPrefixes;
		};

	
	/* Function: GetAllPrefixesIndex
		Returns the index at which the passed prefix appears or should appear in <allPrefixes>.  If it's not found 
		it will return the index it would be inserted at if it were to be added.
	*/
	this.GetAllPrefixesIndex = function (prefix)
		{
		if (this.allPrefixesStatus != `Ready)
			{  return undefined;  }
		if (this.allPrefixes.length == 0)
			{  return 0;  }

		var firstIndex = 0;
		var lastIndex = this.allPrefixes.length - 1;  // lastIndex is inclusive

		for (;;)
			{
			var testIndex = (firstIndex + lastIndex) >> 1;

			if (prefix == this.allPrefixes[testIndex])
				{  return testIndex;  }

			else if (prefix < this.allPrefixes[testIndex])
				{  
				if (testIndex == firstIndex)
					{  return testIndex;  }
				else
					{  
					// Not testIndex - 1 because even though prefix is lower, that may be the position it would be 
					// inserted at.
					lastIndex = testIndex;
					}
				}

			else // prefix > this.allPrefixes[testIndex]
				{
				if (testIndex == lastIndex)
					{  return lastIndex + 1;  }
				else
					{  firstIndex = testIndex + 1;  }
				}
			}
		};


	/* Function: KeywordMatchesInterpretations
		Returns whether the keyword matches any of the passed interpretations.
	*/
	this.KeywordMatchesInterpretations = function (keywordObject, interpretations)
		{
		for (var i = 0; i < interpretations.length; i++)
			{
			var interpretation = interpretations[i];

			// Searching for "acc" in keyword "Access"...
			if (interpretation.length <= keywordObject[`KeywordObject_SearchText].length)
				{
				if (keywordObject[`KeywordObject_SearchText].indexOf(interpretation) != -1)
					{  return true;  }
				}

			// Reverse it to search for "access levels" under keyword "Access"...
			else
				{
				if (interpretation.indexOf(keywordObject[`KeywordObject_SearchText]) != -1)
					{  return true;  }
				}
			}

		return false;
		};


	/* Function: MemberMatchesInterpretations
		Returns whether the keyword member matches any of the passed interpretations.
	*/
	this.MemberMatchesInterpretations = function (memberObject, interpretations)
		{
		for (var i = 0; i < interpretations.length; i++)
			{
			var interpretation = interpretations[i];

			if (memberObject[`MemberObject_SearchText].indexOf(interpretation) != -1)
				{  return true;  }
			}

		return false;
		};

	

	// Group: Build Functions
	// ________________________________________________________________________


	/* Function: BuildResults

		Builds the search results in HTML.  If a prefix data it needs is not loaded yet it will build what it can and return 
		the next one that needs in the results.  If favorClasses is set, links will use the class/database view whenever 
		possible.

		Returns:

			{ html, prefixDataToLoad }
	*/
	this.BuildResults = function (searchInterpretations, searchInterpretationPrefixes, favorClasses)
		{
		var results = {
			// prefixDataToLoad: undefined,
			html: ""
			};

		if (this.allPrefixesStatus != `Ready)
			{
			results.html += this.BuildSearchingStatus();
			return results;
			}

		var addSearchingStatus = false;

		for (var p = 0; p < searchInterpretationPrefixes.length; p++)
			{
			var prefix = searchInterpretationPrefixes[p];

			if (this.prefixObjects[prefix] == undefined)
				{
				results.prefixDataToLoad = prefix;
				addSearchingStatus = true;
				break;
				}
			else if (this.prefixObjects[prefix][`PrefixObject_Ready] == false)
				{
				addSearchingStatus = true;
				break;
				}

			var keywordObjects = this.prefixObjects[prefix][`PrefixObject_KeywordObjects];

			for (var k = 0; k < keywordObjects.length; k++)
				{  results.html += this.BuildKeyword(keywordObjects[k], searchInterpretations, favorClasses);  }
			}
		
		if (addSearchingStatus)
			{  results.html += this.BuildSearchingStatus();  }
		else if (results.html == "")
			{  results.html += this.BuildNoMatchesStatus();  }

		return results;
		};


	/* Function: BuildKeyword
		Builds the results for a keyword and returns the HTML.  The results will be filtered based on <searchText>.  If
		favorClasses is set, links will use the class/database view whenever possible.
	*/
	this.BuildKeyword = function (keywordObject, searchInterpretations, favorClasses)
		{
		if (this.KeywordMatchesInterpretations(keywordObject, searchInterpretations) == false)
			{  return "";  }

		var memberMatches = 0;
		var lastMatchingMemberObject;

		for (var i = 0; i < keywordObject[`KeywordObject_MemberObjects].length; i++)
			{
			var memberObject = keywordObject[`KeywordObject_MemberObjects][i];

			if (this.MemberMatchesInterpretations(memberObject, searchInterpretations))
				{
				lastMatchingMemberObject = memberObject;
				memberMatches++;  
				}
			}

		if (memberMatches == 0)
			{  return "";  }

		else if (memberMatches == 1 &&
				   lastMatchingMemberObject[`MemberObject_SearchText] == keywordObject[`KeywordObject_SearchText])
			{
			var topicType = lastMatchingMemberObject[`MemberObject_TopicType];
			var target;

			if (favorClasses && lastMatchingMemberObject[`MemberObject_ClassHashPath] != undefined)
				{  target = lastMatchingMemberObject[`MemberObject_ClassHashPath];  }
			else
				{  target = lastMatchingMemberObject[`MemberObject_FileHashPath];  }

			var html = "<a class=\"SeEntry T" + topicType + "\" href=\"#" + target + "\">" + 
							   "<div class=\"SeEntryIcon\"></div>" +
							   lastMatchingMemberObject[`MemberObject_HTMLName];

			if (lastMatchingMemberObject[`MemberObject_HTMLQualifier] != undefined)
				{  html += "<span class=\"SeQualifier\">, " + lastMatchingMemberObject[`MemberObject_HTMLQualifier] + "</span>";  }
			
			html += "</a>";
			return html;
			}

		else
			{
			var parentID;
			
			if (keywordObject[`KeywordObject_ParentID] == undefined)
				{
				parentID = this.highestAssignedParentID + 1;
				this.highestAssignedParentID++;

				keywordObject[`KeywordObject_ParentID] = parentID;
				}
			else
				{  parentID = keywordObject[`KeywordObject_ParentID];  }

			var openClosed;

			if (this.openParentIDs.indexOf(parentID) != -1)
				{  openClosed = "open";  }
			else
				{  openClosed = "closed";  }

			var html = "<a class=\"SeEntry SeParent " + openClosed + "\" id=\"SeParent" + parentID + "\" " +
								"href=\"javascript:NDSearch.ToggleParent(" + parentID + ")\">" + 
								"<div class=\"SeEntryIcon\"></div>" +
								keywordObject[`KeywordObject_HTMLName] + 
								" <span class=\"SeChildCount\">(" + memberMatches + ")</span>" +
							"</a>" +
							"<div class=\"SeChildren " + openClosed + "\" id=\"SeChildren" + parentID + "\">";

			for (var i = 0; i < keywordObject[`KeywordObject_MemberObjects].length; i++)
				{
				var memberObject = keywordObject[`KeywordObject_MemberObjects][i];

				if (this.MemberMatchesInterpretations(memberObject, searchInterpretations))
					{
					var topicType = memberObject[`MemberObject_TopicType];
					var target;

					if (favorClasses && memberObject[`MemberObject_ClassHashPath] != undefined)
						{  target = memberObject[`MemberObject_ClassHashPath];  }
					else
						{  target = memberObject[`MemberObject_FileHashPath];  }

					html += "<a class=\"SeEntry T" + topicType + "\" href=\"#" + target + "\">" + 
									"<div class=\"SeEntryIcon\"></div>" +
									memberObject[`MemberObject_HTMLName];

					if (memberObject[`MemberObject_HTMLQualifier] != undefined)
						{  html += "<span class=\"SeQualifier\">, " + memberObject[`MemberObject_HTMLQualifier] + "</span>";  }

					html += "</a>";
					}
				}

			html += "</div>";
			return html;
			}
		};

	
	/* Function: BuildSearchingStatus
	*/
	this.BuildSearchingStatus = function ()
		{
		return "<div class=\"SeStatus Searching\">" + `Locale{HTML.SearchingStatus} + "</div>";
		};


	/* Function: BuildNoMatchesStatus
	*/
	this.BuildNoMatchesStatus = function ()
		{
		return "<div class=\"SeStatus NoResults\">" + `Locale{HTML.NoMatchesStatus} + "</div>";
		};



	// Group: Prefix Functions
	// ________________________________________________________________________


	/* Function: MakePrefix
		Returns the prefix of an individual normalized search string.
	*/
	this.MakePrefix = function (searchText)
		{
		var prefix = "";

		for (var i = 0; i < 3; i++)
			{
			if (i >= searchText.length)
				{  break;  }

			var char = searchText.charAt(i);

			if (char == " " || char == "." || char == "/")
				{  break;  }

			prefix += char;
			}

		if (prefix.length > 0)
			{  return prefix;  }
		else
			{  return undefined;  }
		};


	/* Function: PrefixToHex
	*/
	this.PrefixToHex = function (prefix)
		{
		var hex = "";

		for (var i = 0; i < prefix.length; i++)
			{
			var charValue = "0000" + prefix.charCodeAt(i).toString(16);
			hex += charValue.substr(charValue.length - 4, 4);
			}

		return hex;
		};


	/* Function: PrefixToDataFile
	*/
	this.PrefixToDataFile = function (prefix)
		{
		return "search/keywords/" + this.PrefixToHex(prefix) + ".js";
		};

	
	
	// Group: UI Functions
	// ________________________________________________________________________

	
	/* Function: Activate
	*/
	this.Activate = function ()
		{
		this.domSearchField.value = "";
		NDCore.RemoveClass(this.domSearchField, "DefaultText");

		// Start loading the prefixes index as soon as the search field is first activated.  We don't want to wait
		// until they start typing.
		if (this.allPrefixesStatus == `NotLoaded)
			{
			this.allPrefixesStatus = `Loading;
			NDCore.LoadJavaScript("search/index.js");
			}
		};

	
	/* Function: Deactivate
	*/
	this.Deactivate = function ()
		{
		this.HideResults();

		NDCore.AddClass(this.domSearchField, "DefaultText");
		this.domSearchField.value = `Locale{HTML.DefaultSearchText};

		this.openParentIDs = [ ];
		this.highestAssignedParentID = 0;
		this.prefixObjects = { };

		// Set focus to the content page iframe so that keyboard scrolling works without clicking over to it.
		document.getElementById("CFrame").contentWindow.focus();
		};


	/* Function: IsActive
	*/
	this.IsActive = function ()
		{
		return (NDCore.HasClass(this.domSearchField, "DefaultText") == false);
		};


	/* Function: ShowResults
	*/
	this.ShowResults = function ()
		{
		this.domSearchResults.style.display = "block";
		this.PositionResults();
		};


	/* Function: HideResults
	*/
	this.HideResults = function ()
		{
		this.domSearchResults.style.display = "none";
		};
	

	/* Function: PositionResults
	*/
	this.PositionResults = function ()
		{
		this.domSearchResults.style.visibility = "hidden";


		// First set the position to 0,0 and the width and height back to auto so it will be sized naturally to its content

		NDCore.SetToAbsolutePosition(this.domSearchResults, 0, 0, undefined, undefined);
		this.domSearchResults.style.width = "";
		this.domSearchResults.style.height = "";

		
		// Figure out our desired upper right coordinates

		var urX = this.domSearchField.offsetLeft + this.domSearchField.offsetWidth;
		var urY = this.domSearchField.offsetTop + this.domSearchField.offsetHeight + 5;


		// Figure out our maximum width/height so we don't go off the screen.  We include the footer height not because
		// we care about covering the footer, but because it serves as a good estimate for the URL popup you get in
		// Firefox and Chrome.

		var footer = document.getElementById("NDFooter");

		var maxWidth = urX;
		var maxHeight = NDCore.WindowClientHeight() - urY - (footer.offsetHeight * 2);


		// Resize

		if (this.domSearchResults.offsetHeight > maxHeight)
			{  NDCore.SetToAbsolutePosition(this.domSearchResults, undefined, undefined, undefined, maxHeight);  }
		if (this.domSearchResults.offsetWidth > maxWidth)
			{  NDCore.SetToAbsolutePosition(this.domSearchResults, undefined, undefined, maxWidth, undefined);  }
		else
			{
			// Firefox and Chrome will sometimes not set the automatic width correctly, leaving a horizontal scroll bar where 
			// one isn't necessary.  Weird.  Fix it up for them.  This also fixes the positioning for IE 6 and 7.
			if (this.domSearchResults.scrollWidth > this.domSearchResults.clientWidth)
				{
				var newWidth = this.domSearchResults.offsetWidth + 
									 (this.domSearchResults.scrollWidth - this.domSearchResults.clientWidth) + 5;

				if (newWidth > maxWidth)
					{  newWidth = maxWidth;  }

				NDCore.SetToAbsolutePosition(this.domSearchResults, undefined, undefined, newWidth, undefined);
				}

			// Also make sure the results are at least as wide as the search box.
			if (this.domSearchResults.offsetWidth < this.domSearchField.offsetWidth)
				{
				NDCore.SetToAbsolutePosition(this.domSearchResults, undefined, undefined, this.domSearchField.offsetWidth, undefined);
				}
			}


		// Reposition

		NDCore.SetToAbsolutePosition(this.domSearchResults, urX - this.domSearchResults.offsetWidth, urY, 
												 undefined, undefined);


		this.domSearchResults.style.visibility = "visible";
		};


	/* Function: ToggleParent
	*/
	this.ToggleParent = function (id)
		{
		var domParent = document.getElementById("SeParent" + id);
		var domChildren = document.getElementById("SeChildren" + id);

		if (domParent == undefined || domChildren == undefined)
			{  return;  }

		if (NDCore.HasClass(domParent, "open"))
			{
			NDCore.RemoveClass(domParent, "open");
			NDCore.RemoveClass(domChildren, "open");
			NDCore.AddClass(domParent, "closed");
			NDCore.AddClass(domChildren, "closed");

			var parentIndex = this.openParentIDs.indexOf(id);

			if (parentIndex != -1)
				{  this.openParentIDs.splice(parentIndex, 1);  }
			}
		else
			{
			NDCore.RemoveClass(domParent, "closed");
			NDCore.RemoveClass(domChildren, "closed");
			NDCore.AddClass(domParent, "open");
			NDCore.AddClass(domChildren, "open");

			this.openParentIDs.push(id);
			}

		this.PositionResults();
		};



	// Group: Search Data Functions
	// ________________________________________________________________________

	
	/* Function: OnPrefixIndexLoaded
	*/
	this.OnPrefixIndexLoaded = function (prefixes)
		{
		this.allPrefixes = prefixes;
		this.allPrefixesStatus = `Ready;

		this.Update();
		};

	
	/* Function: LoadPrefixData
		Starts loading the prefix data file associated with the passed prefix if it isn't already loaded or in the process of loading.
	*/
	this.LoadPrefixData = function (prefix)
		{
		if (this.prefixObjects[prefix] == undefined)
			{
			var prefixObject = [ ];

			prefixObject[`PrefixObject_Prefix] = prefix;
			// prefixObject[`PrefixObject_KeywordObjects] = undefined;
			prefixObject[`PrefixObject_Ready] = false;
			prefixObject[`PrefixObject_DOMLoaderID] = "NDPrefixLoader_" + this.PrefixToHex(prefix);

			this.prefixObjects[prefix] = prefixObject;

			NDCore.LoadJavaScript(this.PrefixToDataFile(prefix), prefixObject[`PrefixObject_DOMLoaderID]);
			}
		};


	/* Function: OnPrefixDataLoaded
		Called by the prefix data file when it has finished loading.
	*/
	this.OnPrefixDataLoaded = function (prefix, topicTypes, keywordObjects)
		{
		var prefixObject = this.prefixObjects[prefix];

		// The data file might have been requested but then purged as no longer needed before it came in.  If that's the
		// case then we can just discard the data.
		if (prefixObject == undefined)
			{  return;  }

		// Undo the data deduplication that was applied to the content.
		for (var k = 0; k < keywordObjects.length; k++)
			{
			var keywordObject = keywordObjects[k];

			if (keywordObject[`KeywordObject_SearchText] == undefined)
				{  keywordObject[`KeywordObject_SearchText] = keywordObject[`KeywordObject_HTMLName].toLowerCase();  }

			for (var m = 0; m < keywordObject[`KeywordObject_MemberObjects].length; m++)
				{
				var memberObject = keywordObject[`KeywordObject_MemberObjects][m];

				var topicTypeIndex = memberObject[`MemberObject_TopicType];
				memberObject[`MemberObject_TopicType] = topicTypes[topicTypeIndex];

				if (memberObject[`MemberObject_HTMLName] == undefined)
					{  memberObject[`MemberObject_HTMLName] = keywordObject[`KeywordObject_HTMLName];  }
				if (memberObject[`MemberObject_SearchText] == undefined)
					{  memberObject[`MemberObject_SearchText] = memberObject[`MemberObject_HTMLName].toLowerCase();  }
				}
			}

		prefixObject[`PrefixObject_KeywordObjects] = keywordObjects;
		prefixObject[`PrefixObject_Ready] = true;

		// We don't need the loader anymore.
		NDCore.RemoveScriptElement(prefixObject[`PrefixObject_DOMLoaderID]);

		//	Replace with this line to simulate latency:
		// setTimeout("NDSearch.Update()", 3000);
		this.Update();
		};


	/* Function: RemoveUnusedPrefixObjects
		Removes all entries from <prefixObjects> that are not in the passed prefix list.
	*/
	this.RemoveUnusedPrefixObjects = function (usedPrefixes)
		{
		if (usedPrefixes.length == 0)
			{  
			this.prefixObjects = { };
			return;
			}

		for (var prefix in this.prefixObjects)
			{
			if (usedPrefixes.indexOf(prefix) == -1)
				{
				// Set it to undefined instead of using delete so we don't potentially screw up the for..in iteration.
				this.prefixObjects[prefix] = undefined;
				}
			}
		};


	
	// Group: UI Variables
	// ________________________________________________________________________


	/* var: domSearchField
		The search field DOM element.
	*/

	/* var: domSearchResults
		The search results DOM element.
	*/

	/* var: domSearchResultsContent
		The SeContent section of <domSearchResults>.
	*/

	/* var: updateTimeout
		A timeout to manage the delay between when the user stops typing and when the search results
		update.
	*/

	/* var: openParentIDs
		An array of SeParent IDs that are open.
	*/

	/* var: highestAssignedParentID
		The highest ID number used in building SeParent/SeChildren pairs.
	*/


	// Group: Search Data Variables
	// ________________________________________________________________________


	/* var: allPrefixes
		A sorted array of all the search text prefixes that have data files associated with them.  This is
		what was stored in search/index.js.  This variable is only available if <allPrefixesStatus> is set
		to `Ready.
	*/

	/* var: allPrefixesStatus

		The state of <allPrefixes>, which may be:

		`NotLoaded - search/index.js has not been loaded yet, or even had it's script element added.
		`Loading - search/index.js has had a script element added but the data hasn't returned yet.
		`Ready - search/index.js has been loaded and <allPrefixes> is ready to use.
	*/
		/* Substitutions:
			`NotLoaded = 1
			`Loading = 2
			`Ready = 3
		*/

	/* var: prefixObjects
		A hash mapping prefixes to prefix data objects.
	*/

	};
