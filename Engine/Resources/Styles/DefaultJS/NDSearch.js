/*
	Include in output:

	This file is part of Natural Docs, which is Copyright © 2003-2013 Greg Valure.
	Natural Docs is licensed under version 3 of the GNU Affero General Public
	License (AGPL).  Refer to License.txt or www.naturaldocs.org for the
	complete details.

	This file may be distributed with documentation files generated by Natural Docs.
	Such documentation is not covered by Natural Docs' copyright and licensing,
	and may have its own copyright and distribution terms as decided by its author.

*/

"use strict";


/* Class: NDSearch
	___________________________________________________________________________

*/
var NDSearch = new function ()
	{

	// Group: Functions
	// ________________________________________________________________________


	/* Function: Start
	*/
	this.Start = function ()
		{
		// We delay loading search/index.js until the search field is actually used
		this.mainIndexStatus = `NotLoaded;


		this.searchField = document.getElementById("NDSearchField");

		this.searchField.onfocus = function () {  NDSearch.OnFocus(true);  };
		this.searchField.onblur = function () {  NDSearch.OnFocus(false);  };
		this.searchField.onkeyup = function (event) {  NDSearch.OnKeyUp(event);  };

		this.searchResults = document.createElement("div");
		this.searchResults.id = "NDSearchResults";
		this.searchResults.style.display = "none";
		this.searchResults.style.position = "fixed";

		if (NDCore.IEVersion() == 6)
			{  this.searchResults.style.position = "absolute";  }

		this.searchResults.style.zIndex = 22;  // documented in default.css
		document.body.appendChild(this.searchResults);

		this.Deactivate();
		};


	/* Function: Activate
	*/
	this.Activate = function ()
		{
		this.searchField.value = "";
		NDCore.RemoveClass(this.searchField, "DefaultText");

		// Start loading the main index as soon as the search field is first activated.  We don't want to wait
		// until they start typing.
		if (this.mainIndexStatus == `NotLoaded)
			{
			this.mainIndexStatus = `Loading;
			NDCore.LoadJavaScript("search/index.js");
			}
		};

	
	/* Function: Deactivate
	*/
	this.Deactivate = function ()
		{
		this.HideResults();

		NDCore.AddClass(this.searchField, "DefaultText");
		this.searchField.value = `Locale{HTML.DefaultSearchText};

		// Set focus to the content page iframe so that keyboard scrolling works without clicking over to it.
		document.getElementById("CFrame").contentWindow.focus();
		};


	/* Function: ShowResults
	*/
	this.ShowResults = function ()
		{
		this.searchResults.style.display = "block";
		this.PositionResults();
		};


	/* Function: HideResults
	*/
	this.HideResults = function ()
		{
		this.searchResults.style.display = "none";
		};
	

	/* Function: PositionResults
	*/
	this.PositionResults = function ()
		{
		this.searchResults.style.visibility = "hidden";


		// First set the position to 0,0 and the width and height back to auto so it will be sized naturally to its content

		NDCore.SetToAbsolutePosition(this.searchResults, 0, 0, undefined, undefined);
		this.searchResults.style.width = "";
		this.searchResults.style.height = "";

		
		// Figure out our desired upper right coordinates

		var urX = this.searchField.offsetLeft + this.searchField.offsetWidth;
		var urY = this.searchField.offsetTop + this.searchField.offsetHeight + 5;


		// Figure out our maximum width/height so we don't go off the screen.  We include the footer height not because
		// we care about covering the footer, but because it serves as a good estimate for the URL popup you get in
		// Firefox and Chrome.

		var footer = document.getElementById("NDFooter");

		var maxWidth = urX;
		var maxHeight = NDCore.WindowClientHeight() - urY - footer.offsetHeight - 2;


		// Resize

		if (this.searchResults.offsetHeight > maxHeight)
			{  NDCore.SetToAbsolutePosition(this.searchResults, undefined, undefined, undefined, maxHeight);  }
		if (this.searchResults.offsetWidth > maxWidth)
			{  NDCore.SetToAbsolutePosition(this.searchResults, undefined, undefined, maxWidth, undefined);  }
		else
			{
			// Firefox and Chrome will sometimes not set the automatic width correctly, leaving a horizontal scroll bar where 
			// one isn't necessary.  Weird.  Fix it up for them.  This also fixes the positioning for IE 6 and 7.
			if (this.searchResults.scrollWidth > this.searchResults.clientWidth)
				{
				var newWidth = this.searchResults.offsetWidth + (this.searchResults.scrollWidth - this.searchResults.clientWidth) + 5;

				if (newWidth > maxWidth)
					{  newWidth = maxWidth;  }

				NDCore.SetToAbsolutePosition(this.searchResults, undefined, undefined, newWidth, undefined);
				}
			}


		// Reposition

		NDCore.SetToAbsolutePosition(this.searchResults, urX - this.searchResults.offsetWidth, urY, undefined, undefined);


		this.searchResults.style.visibility = "visible";
		};


	/* Function: MakeSearchText
		Converts the raw text entered in <searchField> to a normalized form compatible with the search text Natural Docs 
		generates.  It will fill in <searchText> and <altSearchText>.
	*/
	this.MakeSearchText = function ()
		{
		// DEPENDENCY: This must match what is done in Engine.SearchIndex.Entry.Normalize().

		var input = this.searchField.value.toLowerCase();

		// Trim and condense whitespace
		input = input.replace(/\s+/g, " ");
		input = input.replace(/^ /, "");
		input = input.replace(/ $/, "");

		// Remove spaces unless between two alphanumeric/underscore characters
		input = input.replace(/([^a-z0-9_]) /g, "$1");  // Substitution because JavaScript has no (?<=) for lookbehinds
		input = input.replace(/ (?=[^a-z0-9_])/g, "");

		// Normalize separators
		input = input.replace(/::|->/g, ".");
		input = input.replace(/\\/g, "/");

		// Remove leading separators.  We don't have to worry about whitespace between them and the rest.
		input = input.replace(/^[./]+/, "");


		this.searchText = input;


		// If the search text ends with : or - it's possible that it's the first character of :: or ->.  Provide an alternate
		// search string so relevant results don't disappear until the second character is added.

		var lastChar = input.charAt(input.length - 1);

		if (lastChar == ":" || lastChar == "-")
			{  this.altSearchText = input.substr(0, input.length - 1) + ".";  }
		else
			{  this.altSearchText = undefined;  }
		};


	/* Function: DataFileOf
	*/
	this.DataFileOf = function (prefix)
		{
		var dataFile = "";

		for (var i = 0; i < prefix.length; i++)
			{
			var charValue = "0000" + prefix.charCodeAt(i).toString(16);
			dataFile += charValue.substr(charValue.length - 4, 4);
			}

		if (dataFile.length > 0)
			{  return "search/keywords/" + dataFile + ".js";  }
		else
			{  return undefined;  }
		};



	// Group: Prefix Functions
	// ________________________________________________________________________


	/* Function: PrefixOf
		Returns the prefix of an individual normalized search string.
	*/
	this.PrefixOf = function (searchText)
		{
		var prefix = "";

		for (var i = 0; i < 3; i++)
			{
			if (i >= searchText.length)
				{  break;  }

			var char = searchText.charAt(i);

			if (char == " " || char == "." || char == "/")
				{  break;  }

			prefix += char;
			}

		if (prefix.length > 0)
			{  return prefix;  }
		else
			{  return undefined;  }
		};


	/* Function: PrefixIndex
		Returns the index at which the passed prefix appears or should appear in <mainIndex>.  If it's not found 
		it will return the index it would be inserted at if it were to be added.
	*/
	this.PrefixIndex = function (prefix)
		{
		if (this.mainIndexStatus != `Ready)
			{  return undefined;  }
		if (this.mainIndex.length == 0)
			{  return 0;  }

		var firstIndex = 0;
		var lastIndex = this.mainIndex.length - 1;  // lastIndex is inclusive

		for (;;)
			{
			var testIndex = (firstIndex + lastIndex) >> 1;

			if (prefix == this.mainIndex[testIndex])
				{  return testIndex;  }

			else if (prefix < this.mainIndex[testIndex])
				{  
				if (testIndex == firstIndex)
					{  return testIndex;  }
				else
					{  
					// Not testIndex - 1 because even though prefix is lower, that may be the position it would be 
					// inserted at.
					lastIndex = testIndex;
					}
				}

			else // prefix > this.mainIndex[testIndex]
				{
				if (testIndex == lastIndex)
					{  return lastIndex + 1;  }
				else
					{  firstIndex = testIndex + 1;  }
				}
			}
		};


	/* Function: GetPrefixesInSearchText
		Returns an array of prefixes that match <searchText> and/or <altSearchText>.  If there are none it will
		return an empty array.
	*/
	this.GetPrefixesInSearchText = function ()
		{
		if (this.mainIndexStatus != `Ready)
			{  return [ ];  }


		// Find the stretch that matches searchText

		var searchPrefix = undefined;
		var searchPrefixIndex = 0;
		var searchPrefixCount = 0;

		if (this.searchText != undefined && this.searchText != "")
			{  searchPrefix = this.PrefixOf(this.searchText);  }

		if (searchPrefix != undefined && searchPrefix != "")
			{
			searchPrefixIndex = this.PrefixIndex(searchPrefix);

			for (var i = searchPrefixIndex; i < this.mainIndex.length; i++)
				{
				if (this.mainIndex[i].length >= searchPrefix.length &&
					this.mainIndex[i].substr(0, searchPrefix.length) == searchPrefix)
					{  searchPrefixCount++;  }
				else
					{  break;  }
				}
			}


		// Find the stretch that matches altSearchText

		var altSearchPrefix = undefined;
		var altSearchPrefixIndex = 0;
		var altSearchPrefixCount = 0;

		if (this.altSearchText != undefined && this.altSearchText != "")
			{  altSearchPrefix = this.PrefixOf(this.altSearchText);  }

		if (altSearchPrefix != undefined && altSearchPrefix != "" && altSearchPrefix != searchPrefix)
			{
			altSearchPrefixIndex = this.PrefixIndex(altSearchPrefix);

			for (var i = altSearchPrefixIndex; i < this.mainIndex.length; i++)
				{
				if (this.mainIndex[i].length >= altSearchPrefix.length &&
					this.mainIndex[i].substr(0, altSearchPrefix.length) == altSearchPrefix)
					{  altSearchPrefixCount++;  }
				else
					{  break;  }
				}
			}


		// At this point we don't care about which stretch came from searchText and which came from altSearchText
		// anymore.  Normalize them so that if there is only one defined it's in the first one, and if they're both defined
		// the lower is first.

		if (searchPrefixCount == 0 && altSearchPrefixCount != 0)
			{
			searchPrefixIndex = altSearchPrefixIndex;
			searchPrefixCount = altSearchPrefixCount;
			altSearchPrefixCount = 0;
			}
		else if (searchPrefixCount != 0 && altSearchPrefixCount != 0 && altSearchIndex < searchIndex)
			{
			var tempSearchPrefixIndex = searchPrefixIndex;
			var tempSearchPrefixCount = searchPrefixCount;
			searchPrefixIndex = altSearchPrefixIndex;
			searchPrefixCount = altSearchPrefixCount;
			altSearchPrefixIndex = tempSearchPrefixIndex;
			altSearchPrefixCount = tempSearchPrefixCount;
			}


		// Return a combined array of results.  We don't want any duplicates.

		if (searchPrefixCount == 0)
			{  return [ ];  }
		else if (altSearchPrefixCount == 0 || 
					(altSearchPrefixIndex == searchPrefixIndex && altSearchPrefixCount <= searchPrefixCount) )
			{  return this.mainIndex.slice(searchPrefixIndex, searchPrefixIndex + searchPrefixCount);  }
		else
			{
			var result;
			var searchPrefixEnd = searchPrefixIndex + searchPrefixCount;
			var altSearchPrefixEnd = altSearchPrefixIndex + altSearchPrefixCount;

			if (searchPrefixEnd <= altSearchPrefixIndex)
				{  result = this.mainIndex.slice(searchPrefixIndex, searchPrefixEnd);  }
			else
				{  result = this.mainIndex.slice(searchPrefixIndex, altSearchPrefixIndex);  }

			result = result.concat(this.mainIndex.slice(altSearchPrefixIndex, altSearchPrefixEnd));

			return result;
			}

		};



	// Group: Event Handlers
	// ________________________________________________________________________


	/* Function: OnFocus
	*/
	this.OnFocus = function (isActive)
		{
		if (isActive)
			{  this.Activate();  }
		else
			{  this.Deactivate();  }
		};


	/* Function: OnKeyUp
	*/
	this.OnKeyUp = function (event)
		{
		if (event === undefined)
			{  event = window.event;  }

		if (event.keyCode == 27)  // ESC
			{  this.Deactivate();  }
		else
			{  this.OnChange();  }
		}


	/* Function: OnChange
	*/
	this.OnChange = function ()
		{
		this.MakeSearchText();

		if (this.searchText == undefined || this.searchText == "")
			{
			this.HideResults();
			return;
			}


		// Show normalized search text

		var output = "[" + this.searchText + "]";

		if (this.altSearchText != undefined && this.altSearchText != "")
			{  output += "<br>[" + this.altSearchText + "]";  }

		output = "<pre>" + output + "</pre>";
		

		// Show prefix matches

		var prefixes = this.GetPrefixesInSearchText();
		
		if (prefixes == undefined || prefixes.length == 0)
			{  output += "No matches";  }
		else
			{
			for (var i = 0; i < prefixes.length; i++)
				{
				output += "<br>" + prefixes[i] + " - " + this.DataFileOf(prefixes[i]);
				}
			}


		this.searchResults.innerHTML = output;
		this.ShowResults();
		}


	/* Function: OnIndexLoaded
	*/
	this.OnIndexLoaded = function (content)
		{
		this.mainIndex = content;
		this.mainIndexStatus = `Ready;
		};


	/* Function: OnUpdateLayout
	*/
	this.OnUpdateLayout = function ()
		{
		// This may be called before Start().
		if (this.searchResults != undefined)
			{  this.PositionResults();  }
		};



	// Group: Variables
	// ________________________________________________________________________

	/* var: searchField
		The search field DOM element.
	*/

	/* var: searchResults
		The search results DOM element.
	*/

	/* var: searchText
		The current search text, normalized.
	*/

	/* var: altSearchText
		An alternate version of the current search text, normalized, if any.  This is for if there can
		be two interpretations of the search text as written.
	*/

	/* var: mainIndex
		A sorted array of the search text prefixes that have data files associated with them.  This is
		what was stored in search/index.js.  This variable is only available if <mainIndexStatus> is set
		to `Ready.
	*/

	/* var: mainIndexStatus
		The state of <mainIndex>, which may be:
		`NotLoaded - search/index.js has not been loaded yet, or even had it's script element added.
		`Loading - search/index.js has had a script element added but the data hasn't returned yet.
		`Ready - search/index.js has been loaded and <mainIndex> is ready to use.
	*/
		/* Substitutions:
			`NotLoaded = 1
			`Loading = 2
			`Ready = 3
		*/

	};
