/*
	Include in output:

	This file is part of Natural Docs, which is Copyright © 2003-2013 Greg Valure.
	Natural Docs is licensed under version 3 of the GNU Affero General Public
	License (AGPL).  Refer to License.txt or www.naturaldocs.org for the
	complete details.

	This file may be distributed with documentation files generated by Natural Docs.
	Such documentation is not covered by Natural Docs' copyright and licensing,
	and may have its own copyright and distribution terms as decided by its author.


	Substitutions:

		`Keyword_HTMLName = 0
		`Keyword_SearchText = 1
		`Keyword_Members = 2
		`Keyword_ParentID = 3

		`Member_HTMLQualifier = 0
		`Member_HTMLName = 1
		`Member_SearchText = 2
		`Member_FileHashPath = 3
		`Member_ClassHashPath = 4

		`UpdateSearchDelay = 350

*/

"use strict";


/* Class: NDSearch
	___________________________________________________________________________

*/
var NDSearch = new function ()
	{

	// Group: Functions
	// ________________________________________________________________________


	/* Function: Start
	*/
	this.Start = function ()
		{
		// We delay loading search/index.js until the search field is actually used
		this.mainIndexStatus = `NotLoaded;
		this.keywordSegments = { };
		this.highestAssignedParentID = 0;
		this.openParentIDs = [ ];


		this.domSearchField = document.getElementById("NDSearchField");

		this.domSearchField.onfocus = function () {  NDSearch.OnFieldFocus(true);  };
		this.domSearchField.onblur = function () {  NDSearch.OnFieldFocus(false);  };
		this.domSearchField.onkeyup = function (event) {  NDSearch.OnFieldKeyUp(event);  };

		this.domSearchResults = document.createElement("div");
		this.domSearchResults.id = "NDSearchResults";
		this.domSearchResults.style.display = "none";
		this.domSearchResults.style.position = "fixed";

		if (NDCore.IEVersion() == 6)
			{  this.domSearchResults.style.position = "absolute";  }

		this.domSearchResults.onfocus = function () {  NDSearch.OnResultsFocus(true);  };
		this.domSearchResults.onblur = function () {  NDSearch.OnResultsFocus(false);  };
		this.domSearchResults.onkeyup = function (event) {  NDSearch.OnResultsKeyUp(event);  };

		var domSearchResultsContent = document.createElement("div");
		domSearchResultsContent.id = "ShContent";

		this.domSearchResults.appendChild(domSearchResultsContent);
		document.body.appendChild(this.domSearchResults);

		this.Deactivate();
		};



	// Group: UI Functions
	// ________________________________________________________________________

	
	/* Function: Activate
	*/
	this.Activate = function ()
		{
		this.domSearchField.value = "";
		NDCore.RemoveClass(this.domSearchField, "DefaultText");

		// Start loading the main index as soon as the search field is first activated.  We don't want to wait
		// until they start typing.
		if (this.mainIndexStatus == `NotLoaded)
			{
			this.mainIndexStatus = `Loading;
			NDCore.LoadJavaScript("search/index.js");
			}
		};

	
	/* Function: Deactivate
	*/
	this.Deactivate = function ()
		{
		this.HideResults();

		NDCore.AddClass(this.domSearchField, "DefaultText");
		this.domSearchField.value = `Locale{HTML.DefaultSearchText};

		this.searchText = undefined;
		this.altSearchText = undefined;
		this.prefixesInSearchText = undefined;

		this.keywordSegments = { };
		this.highestAssignedParentID = 0;
		this.openParentIDs = [ ];

		// Set focus to the content page iframe so that keyboard scrolling works without clicking over to it.
		document.getElementById("CFrame").contentWindow.focus();
		};


	/* Function: IsActive
	*/
	this.IsActive = function ()
		{
		return (NDCore.HasClass(this.domSearchField, "DefaultText") == false);
		};


	/* Function: ShowResults
	*/
	this.ShowResults = function ()
		{
		this.domSearchResults.style.display = "block";
		this.PositionResults();
		};


	/* Function: HideResults
	*/
	this.HideResults = function ()
		{
		this.domSearchResults.style.display = "none";
		};
	

	/* Function: PositionResults
	*/
	this.PositionResults = function ()
		{
		this.domSearchResults.style.visibility = "hidden";


		// First set the position to 0,0 and the width and height back to auto so it will be sized naturally to its content

		NDCore.SetToAbsolutePosition(this.domSearchResults, 0, 0, undefined, undefined);
		this.domSearchResults.style.width = "";
		this.domSearchResults.style.height = "";

		
		// Figure out our desired upper right coordinates

		var urX = this.domSearchField.offsetLeft + this.domSearchField.offsetWidth;
		var urY = this.domSearchField.offsetTop + this.domSearchField.offsetHeight + 5;


		// Figure out our maximum width/height so we don't go off the screen.  We include the footer height not because
		// we care about covering the footer, but because it serves as a good estimate for the URL popup you get in
		// Firefox and Chrome.

		var footer = document.getElementById("NDFooter");

		var maxWidth = urX;
		var maxHeight = NDCore.WindowClientHeight() - urY - (footer.offsetHeight * 2);


		// Resize

		if (this.domSearchResults.offsetHeight > maxHeight)
			{  NDCore.SetToAbsolutePosition(this.domSearchResults, undefined, undefined, undefined, maxHeight);  }
		if (this.domSearchResults.offsetWidth > maxWidth)
			{  NDCore.SetToAbsolutePosition(this.domSearchResults, undefined, undefined, maxWidth, undefined);  }
		else
			{
			// Firefox and Chrome will sometimes not set the automatic width correctly, leaving a horizontal scroll bar where 
			// one isn't necessary.  Weird.  Fix it up for them.  This also fixes the positioning for IE 6 and 7.
			if (this.domSearchResults.scrollWidth > this.domSearchResults.clientWidth)
				{
				var newWidth = this.domSearchResults.offsetWidth + 
									 (this.domSearchResults.scrollWidth - this.domSearchResults.clientWidth) + 5;

				if (newWidth > maxWidth)
					{  newWidth = maxWidth;  }

				NDCore.SetToAbsolutePosition(this.domSearchResults, undefined, undefined, newWidth, undefined);
				}

			// Also make sure the results are at least as wide as the search box.
			if (this.domSearchResults.offsetWidth < this.domSearchField.offsetWidth)
				{
				NDCore.SetToAbsolutePosition(this.domSearchResults, undefined, undefined, this.domSearchField.offsetWidth, undefined);
				}
			}


		// Reposition

		NDCore.SetToAbsolutePosition(this.domSearchResults, urX - this.domSearchResults.offsetWidth, urY, 
												 undefined, undefined);


		this.domSearchResults.style.visibility = "visible";
		};


	/* Function: ToggleParent
	*/
	this.ToggleParent = function (id)
		{
		var domParent = document.getElementById("ShParent" + id);
		var domChildren = document.getElementById("ShChildren" + id);

		if (domParent == undefined || domChildren == undefined)
			{  return;  }

		if (NDCore.HasClass(domParent, "open"))
			{
			NDCore.RemoveClass(domParent, "open");
			NDCore.RemoveClass(domChildren, "open");
			NDCore.AddClass(domParent, "closed");
			NDCore.AddClass(domChildren, "closed");
			}
		else
			{
			NDCore.RemoveClass(domParent, "closed");
			NDCore.RemoveClass(domChildren, "closed");
			NDCore.AddClass(domParent, "open");
			NDCore.AddClass(domChildren, "open");
			}

		this.PositionResults();
		};



	// Group: Prefix Functions
	// ________________________________________________________________________


	/* Function: PrefixOf
		Returns the prefix of an individual normalized search string.
	*/
	this.PrefixOf = function (searchText)
		{
		var prefix = "";

		for (var i = 0; i < 3; i++)
			{
			if (i >= searchText.length)
				{  break;  }

			var char = searchText.charAt(i);

			if (char == " " || char == "." || char == "/")
				{  break;  }

			prefix += char;
			}

		if (prefix.length > 0)
			{  return prefix;  }
		else
			{  return undefined;  }
		};


	/* Function: PrefixIndex
		Returns the index at which the passed prefix appears or should appear in <mainIndex>.  If it's not found 
		it will return the index it would be inserted at if it were to be added.
	*/
	this.PrefixIndex = function (prefix)
		{
		if (this.mainIndexStatus != `Ready)
			{  return undefined;  }
		if (this.mainIndex.length == 0)
			{  return 0;  }

		var firstIndex = 0;
		var lastIndex = this.mainIndex.length - 1;  // lastIndex is inclusive

		for (;;)
			{
			var testIndex = (firstIndex + lastIndex) >> 1;

			if (prefix == this.mainIndex[testIndex])
				{  return testIndex;  }

			else if (prefix < this.mainIndex[testIndex])
				{  
				if (testIndex == firstIndex)
					{  return testIndex;  }
				else
					{  
					// Not testIndex - 1 because even though prefix is lower, that may be the position it would be 
					// inserted at.
					lastIndex = testIndex;
					}
				}

			else // prefix > this.mainIndex[testIndex]
				{
				if (testIndex == lastIndex)
					{  return lastIndex + 1;  }
				else
					{  firstIndex = testIndex + 1;  }
				}
			}
		};


	/* Function: PrefixToHex
	*/
	this.PrefixToHex = function (prefix)
		{
		var hex = "";

		for (var i = 0; i < prefix.length; i++)
			{
			var charValue = "0000" + prefix.charCodeAt(i).toString(16);
			hex += charValue.substr(charValue.length - 4, 4);
			}

		return hex;
		};


	/* Function: PrefixToDataFile
	*/
	this.PrefixToDataFile = function (prefix)
		{
		return "search/keywords/" + this.PrefixToHex(prefix) + ".js";
		};



	// Group: Search Functions
	// ________________________________________________________________________


	/* Function: Update
	*/
	this.Update = function ()
		{
		// This may be called by segment data loaders after the field was deactivated so we have to check.
		if (!this.IsActive())
			{  return;  }

		var status = this.UpdateAndBuildResults();

		if (status.newContent == undefined)
			{  this.HideResults();  }
		else
			{
			var oldContent = document.getElementById("ShContent");
			this.domSearchResults.replaceChild(status.newContent, oldContent);

			this.ShowResults();
			}

		if (status.keywordSegmentToLoad != undefined)
			{  this.LoadKeywordSegment(status.keywordSegmentToLoad);  }
		};

	
	/* Function: UpdateAndBuildResults

		Updates the internal search variables and builds and returns a new ShContent DOM element for the current 
		search state.  If the results pane should not be shown it will return undefined.

		This is the complete process from reading <domSearchField>, to setting state variables like <searchText>
		and <prefixesInSearchText>, to queueing more prefix elements for loading, to building the final ShContent 
		element.  This is only separated from <Update()> to make returning early while building ShContent easier.

		Returns:

			> { newContent, keywordSegmentToLoad }
	*/
	this.UpdateAndBuildResults = function ()
		{
		var status = {
			newContent: undefined,
			keywordSegmentToLoad: undefined
			};

		this.UpdateSearchText();

		if (this.searchText == undefined || this.searchText == "")
			{
			this.prefixesInSearchText = undefined;
			this.PurgeUnusedSegments();
			return status;
			}

		status.newContent = document.createElement("div");
		status.newContent.id = "ShContent";

		if (this.mainIndexStatus != `Ready)
			{
			this.AddSearchingStatus(status.newContent);
			return status;
			}

		this.UpdatePrefixesInSearchText();
		this.PurgeUnusedSegments();

		if (this.prefixesInSearchText == undefined)
			{
			this.AddNoMatchesStatus(status.newContent);
			return status;
			}

		var location = new NDLocation(window.location.hash);
		var favorClasses = (location.type == "Class" || location.type == "Database");
		var htmlResults = "";
		var addSearchingStatus = false;

		for (var p = 0; p < this.prefixesInSearchText.length; p++)
			{
			var prefix = this.prefixesInSearchText[p];

			if (this.keywordSegments[prefix] == undefined)
				{
				status.keywordSegmentToLoad = prefix;
				addSearchingStatus = true;
				break;
				}
			else if (this.keywordSegments[prefix].ready == false)
				{
				addSearchingStatus = true;
				break;
				}

			var keywords = this.keywordSegments[prefix].content;

			for (var i = 0; i < keywords.length; i++)
				{  htmlResults += this.BuildKeyword(keywords[i], favorClasses);  }
			}
		
		if (htmlResults == "" && !addSearchingStatus)
			{  this.AddNoMatchesStatus(status.newContent);  }
		else
			{  
			status.newContent.innerHTML = htmlResults;

			if (addSearchingStatus)
				{  this.AddSearchingStatus(status.newContent);  }
			}

		return status;
		};

	
	/* Function: UpdateSearchText
		Converts the raw text entered in <domSearchField> to a normalized form compatible with the search text Natural Docs 
		generates.  It will fill in <searchText> and <altSearchText>.  Returns whether they changed.
	*/
	this.UpdateSearchText = function ()
		{
		// DEPENDENCY: This must match what is done in Engine.SearchIndex.Entry.Normalize().

		var changed = false;
		var newSearchText = this.domSearchField.value.toLowerCase();

		// Trim and condense whitespace
		newSearchText = newSearchText.replace(/\s+/g, " ");
		newSearchText = newSearchText.replace(/^ /, "");
		newSearchText = newSearchText.replace(/ $/, "");

		// Remove spaces unless between two alphanumeric/underscore characters
		newSearchText = newSearchText.replace(/([^a-z0-9_]) /g, "$1");  // Substitution because JavaScript has no (?<=) for lookbehinds
		newSearchText = newSearchText.replace(/ (?=[^a-z0-9_])/g, "");

		// Normalize separators
		newSearchText = newSearchText.replace(/::|->/g, ".");
		newSearchText = newSearchText.replace(/\\/g, "/");

		// Remove leading separators.  We don't have to worry about whitespace between them and the rest.
		newSearchText = newSearchText.replace(/^[./]+/, "");

		if (newSearchText != this.searchText)
			{
			this.searchText = newSearchText;
			changed = true;
			}


		// If the search text ends with : or - it's possible that it's the first character of :: or ->.  Provide an alternate
		// search string so relevant results don't disappear until the second character is added.

		var lastChar = newSearchText.charAt(newSearchText.length - 1);
		var newAltSearchText;

		if (lastChar == ":" || lastChar == "-")
			{  newAltSearchText = newSearchText.substr(0, newSearchText.length - 1) + ".";  }
		else
			{  newAltSearchText = undefined;  }

		if (newAltSearchText != this.altSearchText)
			{
			this.altSearchText = newAltSearchText;
			changed = true;
			}

		return changed;
		};

	
	/* Function: UpdatePrefixesInSearchText
		Creates <prefixesInSearchText> from <searchText> and <altSearchText>.  Returns whether it changed.
	*/
	this.UpdatePrefixesInSearchText = function ()
		{
		if (this.mainIndexStatus != `Ready)
			{  
			this.prefixesInSearchText = undefined;
			return false;
			}


		// Find the stretch that matches searchText

		var searchPrefix = undefined;
		var searchPrefixIndex = 0;
		var searchPrefixCount = 0;

		if (this.searchText != undefined && this.searchText != "")
			{  searchPrefix = this.PrefixOf(this.searchText);  }

		if (searchPrefix != undefined && searchPrefix != "")
			{
			searchPrefixIndex = this.PrefixIndex(searchPrefix);

			for (var i = searchPrefixIndex; i < this.mainIndex.length; i++)
				{
				if (this.mainIndex[i].length >= searchPrefix.length &&
					this.mainIndex[i].substr(0, searchPrefix.length) == searchPrefix)
					{  searchPrefixCount++;  }
				else
					{  break;  }
				}
			}


		// Find the stretch that matches altSearchText

		var altSearchPrefix = undefined;
		var altSearchPrefixIndex = 0;
		var altSearchPrefixCount = 0;

		if (this.altSearchText != undefined && this.altSearchText != "")
			{  altSearchPrefix = this.PrefixOf(this.altSearchText);  }

		if (altSearchPrefix != undefined && altSearchPrefix != "" && altSearchPrefix != searchPrefix)
			{
			altSearchPrefixIndex = this.PrefixIndex(altSearchPrefix);

			for (var i = altSearchPrefixIndex; i < this.mainIndex.length; i++)
				{
				if (this.mainIndex[i].length >= altSearchPrefix.length &&
					this.mainIndex[i].substr(0, altSearchPrefix.length) == altSearchPrefix)
					{  altSearchPrefixCount++;  }
				else
					{  break;  }
				}
			}


		// At this point we don't care about which stretch came from searchText and which came from altSearchText
		// anymore.  Normalize them so that if there is only one defined it's in the first one, and if they're both defined
		// the lower is first.

		if (searchPrefixCount == 0 && altSearchPrefixCount != 0)
			{
			searchPrefixIndex = altSearchPrefixIndex;
			searchPrefixCount = altSearchPrefixCount;
			altSearchPrefixCount = 0;
			}
		else if (searchPrefixCount != 0 && altSearchPrefixCount != 0 && altSearchIndex < searchIndex)
			{
			var tempSearchPrefixIndex = searchPrefixIndex;
			var tempSearchPrefixCount = searchPrefixCount;
			searchPrefixIndex = altSearchPrefixIndex;
			searchPrefixCount = altSearchPrefixCount;
			altSearchPrefixIndex = tempSearchPrefixIndex;
			altSearchPrefixCount = tempSearchPrefixCount;
			}


		// Create a combined array of results.  We don't want any duplicates.

		var newPrefixesInSearchText;

		if (searchPrefixCount == 0)
			{  
			newPrefixesInSearchText = undefined;  
			}
		else if (altSearchPrefixCount == 0 || 
					(altSearchPrefixIndex == searchPrefixIndex && altSearchPrefixCount <= searchPrefixCount) )
			{  
			newPrefixesInSearchText = this.mainIndex.slice(searchPrefixIndex, searchPrefixIndex + searchPrefixCount);  
			}
		else
			{
			var searchPrefixEnd = searchPrefixIndex + searchPrefixCount;
			var altSearchPrefixEnd = altSearchPrefixIndex + altSearchPrefixCount;

			if (searchPrefixEnd <= altSearchPrefixIndex)
				{  newPrefixesInSearchText = this.mainIndex.slice(searchPrefixIndex, searchPrefixEnd);  }
			else
				{  newPrefixesInSearchText = this.mainIndex.slice(searchPrefixIndex, altSearchPrefixIndex);  }

			newPrefixesInSearchText = newPrefixesInSearchText.concat(
													this.mainIndex.slice(altSearchPrefixIndex, altSearchPrefixEnd) );
			}


		// Compare

		var result;

		if (this.prefixesInSearchText == undefined && newPrefixesInSearchText == undefined)
			{  result = false;  }
		else if (this.prefixesInSearchText == undefined || newPrefixesInSearchText == undefined)
			{  result = true;  }
		else if (this.prefixesInSearchText.length != newPrefixesInSearchText.length)
			{  result = true;  }
		else
			{
			result = true;

			for (var i = 0; i < newPrefixesInSearchText; i++)
				{
				if (this.prefixesInSearchText[i] != newPrefixesInSearchText[i])
					{
					result = false;
					break;
					}
				}
			}

		this.prefixesInSearchText = newPrefixesInSearchText;
		return result;
		};


	/* Function: KeywordMatchesSearchText
	*/
	this.KeywordMatchesSearchText = function (keyword)
		{
		// Searching for "acc" in keyword "Access"...
		if (this.searchText.length <= keyword[`Keyword_SearchText].length)
			{
			return ( keyword[`Keyword_SearchText].indexOf(this.searchText) != -1 ||
					   (this.altSearchText != undefined && keyword[`Keyword_SearchText].indexOf(this.altSearchText) != -1) );
			}
		// Reverse it to search for "access levels" under keyword "Access"...
		else
			{
			return ( this.searchText.indexOf(keyword[`Keyword_SearchText]) != -1 ||
					   (this.altSearchText != undefined && this.altSearchText(keyword[`Keyword_SearchText]) != -1) );
			}
		};


	/* Function: KeywordMemberMatchesSearchText
	*/
	this.KeywordMemberMatchesSearchText = function (member)
		{
		return ( member[`Member_SearchText].indexOf(this.searchText) != -1 ||
				   (this.altSearchText != undefined && member[`Member_SearchText].indexOf(this.altSearchText) != -1) );
		};


	/* Function: BuildKeyword
	*/
	this.BuildKeyword = function (keyword, favorClasses)
		{
		if (this.KeywordMatchesSearchText(keyword) == false)
			{  return "";  }

		var memberMatches = 0;
		var lastMatch;

		for (var i = 0; i < keyword[`Keyword_Members].length; i++)
			{
			var member = keyword[`Keyword_Members][i];

			if (this.KeywordMemberMatchesSearchText(member))
				{
				lastMatch = member;
				memberMatches++;  
				}
			}

		if (memberMatches == 0)
			{  return "";  }

		else if (memberMatches == 1 && lastMatch[`Member_SearchText] == keyword[`Keyword_SearchText])
			{
			var target;

			if (favorClasses && lastMatch[`Member_ClassHashPath] != undefined)
				{  target = lastMatch[`Member_ClassHashPath];  }
			else
				{  target = lastMatch[`Member_FileHashPath];  }

			var html = "<a class=\"ShEntry\" href=\"#" + target + "\">" + lastMatch[`Member_HTMLName];

			if (lastMatch[`Member_HTMLQualifier] != undefined)
				{  html += "<span class=\"ShQualifier\">, " + lastMatch[`Member_HTMLQualifier] + "</span>";  }
			
			html += "</a>";
			return html;
			}

		else // memberMatches >= 2
			{
			var parentID;
			
			if (keyword[`Keyword_ParentID] == undefined)
				{
				parentID = this.highestAssignedParentID + 1;
				this.highestAssignedParentID++;

				keyword[`Keyword_ParentID] = parentID;
				}
			else
				{  parentID = keyword[`Keyword_ParentID];  }

			var html = "<a class=\"ShEntry ShParent closed\" id=\"ShParent" + parentID + "\" " +
								"href=\"javascript:NDSearch.ToggleParent(" + parentID + ")\">" + 
								keyword[`Keyword_HTMLName] + 
								" <span class=\"ShChildCount\">(" + memberMatches + ")</span>" +
							"</a>" +
							"<div class=\"ShChildren closed\" id=\"ShChildren" + parentID + "\">";

			for (var i = 0; i < keyword[`Keyword_Members].length; i++)
				{
				var member = keyword[`Keyword_Members][i];

				if (this.KeywordMemberMatchesSearchText(member))
					{
					var target;

					if (favorClasses && member[`Member_ClassHashPath] != undefined)
						{  target = member[`Member_ClassHashPath];  }
					else
						{  target = member[`Member_FileHashPath];  }

					html += "<a class=\"ShEntry\" href=\"#" + target + "\">" + member[`Member_HTMLName];

					if (member[`Member_HTMLQualifier] != undefined)
						{  html += "<span class=\"ShQualifier\">, " + member[`Member_HTMLQualifier] + "</span>";  }

					html += "</a>";
					}
				}

			html += "</div>";
			return html;
			}
		};

	
	/* Function: BuildKeywordMembers
		
		Returns:

			{ numberOfMatches, html }
	*/
	this.BuildKeywordMembers = function (members, favorClasses)
		{
		var result = {
			numberOfMatches: 0,
			html: ""
			};

		for (var i = 0; i < members.length; i++)
			{
			var member = members[i];

			if (member[`Member_SearchText].indexOf(this.searchText) != -1 ||
				(this.altSearchText != undefined && member[`Member_SearchText].indexOf(this.altSearchText) != -1))
				{
				var target;

				if (favorClasses && member[`Member_ClassHashPath] != undefined)
					{  target = member[`Member_ClassHashPath];  }
				else
					{  target = member[`Member_FileHashPath];  }

				result.html += "<a class=\"ShEntry\" href=\"#" + target + "\">";

				if (member[`Member_HTMLQualifier] != undefined)
					{  result.html += "<span class=\"ShQualifier\">" + member[`Member_HTMLQualifier] + "</span>";  }
				
				result.html += member[`Member_HTMLName] + "</a>";
				result.numberOfMatches++;
				}
			}

		return result;
		};

	
	/* Function: AddSearchingStatus
	*/
	this.AddSearchingStatus = function (domElement)
		{
		var status = document.createElement("div");
		status.className = "ShStatus Searching";
		status.innerHTML = `Locale{HTML.SearchingStatus};

		domElement.appendChild(status);
		};


	/* Function: AddNoMatchesStatus
	*/
	this.AddNoMatchesStatus = function (domElement)
		{
		var status = document.createElement("div");
		status.className = "ShStatus NoResults";
		status.innerHTML = `Locale{HTML.NoMatchesStatus};

		domElement.appendChild(status);
		};



	// Group: Segment Functions
	// ________________________________________________________________________

	
	/* Function: OnIndexLoaded
	*/
	this.OnIndexLoaded = function (content)
		{
		this.mainIndex = content;
		this.mainIndexStatus = `Ready;

		this.Update();
		};

	
	/* Function: LoadKeywordSegment
		Starts loading the keyword segment with the passed prefix if it isn't already loaded or in the process of loading.
	*/
	this.LoadKeywordSegment = function (prefix)
		{
		if (this.keywordSegments[prefix] == undefined)
			{
			var segment = {
				prefix: prefix,
				content: undefined,
				ready: false,
				domLoaderID: "NDKeywordLoader_" + this.PrefixToHex(prefix)
				};

			this.keywordSegments[prefix] = segment;

			NDCore.LoadJavaScript(this.PrefixToDataFile(prefix), segment.domLoaderID);
			}
		};


	/* Function: OnKeywordSegmentLoaded
		Called by the keyword segment data file when it has finished loading.
	*/
	this.OnKeywordSegmentLoaded = function (prefix, content)
		{
		var entry = this.keywordSegments[prefix];

		// The data file might have been requested but then purged as no longer needed before it came in.  If that's the
		// case then we can just discard the data.
		if (entry == undefined)
			{  return;  }

		// Undo the data deduplication that was applied to the content.
		for (var k = 0; k < content.length; k++)
			{
			var keyword = content[k];

			if (keyword[`Keyword_SearchText] == undefined)
				{  keyword[`Keyword_SearchText] = keyword[`Keyword_HTMLName].toLowerCase();  }

			for (var m = 0; m < keyword[`Keyword_Members].length; m++)
				{
				var member = keyword[`Keyword_Members][m];

				if (member[`Member_HTMLName] == undefined)
					{  member[`Member_HTMLName] = keyword[`Keyword_HTMLName];  }
				if (member[`Member_SearchText] == undefined)
					{  member[`Member_SearchText] = member[`Member_HTMLName].toLowerCase();  }
				}
			}

		entry.content = content;
		entry.ready = true;

		// We don't need the loader anymore.
		NDCore.RemoveScriptElement(entry.domLoaderID);

		//	Replace with this line to simulate latency:
		// setTimeout("NDSearch.Update()", 1500);
		this.Update();
		};


	/* Function: PurgeUnusedSegments
		Removes all segments from <keywordSegments> that are not represented in <prefixesInSearchText>.
	*/
	this.PurgeUnusedSegments = function ()
		{
		if (this.prefixesInSearchText == undefined || this.prefixesInSearchText.length == 0)
			{  
			this.keywordSegments = { };
			return;
			}

		for (var prefix in this.keywordSegments)
			{
			var isUsed = false;

			for (var i = 0; i < this.prefixesInSearchText.length; i++)
				{
				if (this.prefixesInSearchText[i] == prefix)
					{
					isUsed = true;
					break;
					}
				}

			if (!isUsed)
				{
				// Set it to undefined instead of using delete so we don't potentially screw up the for..in iteration.
				this.keywordSegments[prefix] = undefined;
				}
			}
		};


	
	// Group: Event Handlers
	// ________________________________________________________________________


	/* Function: OnFieldFocus
	*/
	this.OnFieldFocus = function (hasFocus)
		{
		if (hasFocus)
			{
			if (!this.IsActive())
				{  this.Activate();  }
			// Otherwise it might be receiving focus back from the search results
			}
		else
			{  
			// IE switches focus to the results if you click on a scroll bar
//			if (document.activeElement == undefined || document.activeElement.id != "NDSearchResults")
//				{  this.Deactivate();  }
			}
		};


	/* Function: OnFieldKeyUp
	*/
	this.OnFieldKeyUp = function (event)
		{
		if (event === undefined)
			{  event = window.event;  }

		if (event.keyCode == 27)  // ESC
			{  this.Deactivate();  }
		else
			{
			// Reset the countdown on every keystroke
			if (this.updateSearchTimeout != undefined)
				{  clearTimeout(this.updateSearchTimeout);  }

			this.updateSearchTimeout = setTimeout(
				function ()
					{
					clearTimeout(NDSearch.updateSearchTimeout);
					NDSearch.updateSearchTimeout = undefined;

					NDSearch.Update();
					},
				`UpdateSearchDelay);
			}
		}


	/* Function: OnResultsFocus
	*/
	this.OnResultsFocus = function (hasFocus)
		{
		if (hasFocus == false)
			{  
			if (document.activeElement == undefined || document.activeElement.id != "NDSearchField")
				{  this.Deactivate();  }
			}
		};


	/* Function: OnResultsKeyUp
	*/
	this.OnResultsKeyUp = function (event)
		{
		if (event === undefined)
			{  event = window.event;  }

		if (event.keyCode == 27)  // ESC
			{  this.Deactivate();  }
		}


	/* Function: OnUpdateLayout
	*/
	this.OnUpdateLayout = function ()
		{
		// This may be called before Start().
		if (this.domSearchResults != undefined)
			{  this.PositionResults();  }
		};



	// Group: Variables
	// ________________________________________________________________________

	/* var: domSearchField
		The search field DOM element.
	*/

	/* var: domSearchResults
		The search results DOM element.
	*/

	/* var: searchText
		The current search text, normalized.
	*/

	/* var: altSearchText
		An alternate version of the current search text, normalized, if any.  This is for if there can
		be two interpretations of the search text as written.
	*/

	/* var: prefixesInSearchText
		An array of prefixes that match <searchText> and/or <altSearchText>.  If there are none it will
		be undefined.
	*/

	/* var: updateSearchTimeout
		A timeout to manage the delay between when the user stops typing and when the search results
		update.
	*/

	/* var: mainIndex
		A sorted array of the search text prefixes that have data files associated with them.  This is
		what was stored in search/index.js.  This variable is only available if <mainIndexStatus> is set
		to `Ready.
	*/

	/* var: mainIndexStatus
		The state of <mainIndex>, which may be:
		`NotLoaded - search/index.js has not been loaded yet, or even had it's script element added.
		`Loading - search/index.js has had a script element added but the data hasn't returned yet.
		`Ready - search/index.js has been loaded and <mainIndex> is ready to use.
	*/
		/* Substitutions:
			`NotLoaded = 1
			`Loading = 2
			`Ready = 3
		*/

	/* var: keywordSegments
		A hash mapping segment IDs to <NDKeywordSegments>.
	*/

	/* var: highestAssignedParentID
		The highest ID number used in building ShParent/ShChildren pairs.
	*/

	/* var: openParentIDs
		An array of ShParent IDs that are open.
	*/

	};




/* Class: NDKeywordSegment
	___________________________________________________________________________

	An object representing a keyword segment of search index data.

		var: id
		The segment ID string, such as "acc".

		var: ready
		True if the data has been loaded and is ready to use.  False if the data has been requested but is not ready 
		yet.  If the data has not been requested there simply would not be a NDKeywordSegment object for it.

		var: content
		The content of the segment as an array of keywords.

		var: domLoaderID
		The ID of the DOM script object that's loading this file.

*/
